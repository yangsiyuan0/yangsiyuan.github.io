<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git工作流</title>
    <url>/2019/10/24/Git%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="一-分支管理"><a href="#一-分支管理" class="headerlink" title="一.分支管理"></a>一.分支管理</h1><p>开发过程中主要存在以下分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- master</span><br><span class="line">- dev</span><br><span class="line">- hotfix-[问题名称][bug编号]</span><br><span class="line">- feature-[功能名称]</span><br><span class="line">- bugfix-[bug编号]</span><br><span class="line">- refactor-[重构名称]</span><br></pre></td></tr></table></figure>
<h2 id="1-master分支"><a href="#1-master分支" class="headerlink" title="1. master分支"></a>1. master分支</h2><ul>
<li>稳定的可发布版本</li>
<li>由发布人负责管理(合并操作)</li>
<li>不允许提交代码、不允许开发</li>
</ul>
<h2 id="2-dev分支"><a href="#2-dev分支" class="headerlink" title="2. dev分支"></a>2. dev分支</h2><ul>
<li>不稳定分支，功能完整，允许bug</li>
<li>原则上不允许直接在dev分支上进行功能开发，必须新建feature分支进行开发</li>
</ul>
<h2 id="3-hotfix-问题名称-bug编号-分支"><a href="#3-hotfix-问题名称-bug编号-分支" class="headerlink" title="3. hotfix-[问题名称][bug编号]分支"></a>3. hotfix-[问题名称][bug编号]分支</h2><ul>
<li>从master分支创建，横线后面跟上问题名称或者对应的bug编号，仅仅适用于<strong>生产线问题紧急修复</strong>！！！</li>
<li>修复完成，测试通过，合并到master和dev分支上，然后将此分支删除</li>
</ul>
<h2 id="4-feature-功能名称-分支"><a href="#4-feature-功能名称-分支" class="headerlink" title="4. feature-[功能名称]分支"></a>4. feature-[功能名称]分支</h2><ul>
<li>从dev分支创建，横线后跟功能名称，用于新功能开发，每天下班前push提交到远程</li>
<li>开发完成以后，在远程发起向dev分支的合并请求，由指定的CodeReview人员审查通过以后进行合并，并删除该分支</li>
</ul>
<h2 id="5-bugfix-bug编号-分支"><a href="#5-bugfix-bug编号-分支" class="headerlink" title="5. bugfix-[bug编号]分支"></a>5. bugfix-[bug编号]分支</h2><ul>
<li>从dev分支创建，用于修改测试提出的bug，横线后跟bug编号</li>
<li>修复以后，在远程发起向dev分支的合并请求，并指定提交者自身（或其他人）作为CodeReview，合并以后删除该分支</li>
</ul>
<h2 id="6-refactor-重构名称-分支"><a href="#6-refactor-重构名称-分支" class="headerlink" title="6. refactor-[重构名称]分支"></a>6. refactor-[重构名称]分支</h2><ul>
<li>从dev分支创建，用于代码的<strong>重大规模重构</strong>（小规模重构创建feature分支即可）</li>
<li>重构以后，必须经过严格测试通过，才能向dev分支合并</li>
</ul>
<h1 id="二-Commit提交规范"><a href="#二-Commit提交规范" class="headerlink" title="二. Commit提交规范"></a>二. Commit提交规范</h1><h2 id="1-备注格式"><a href="#1-备注格式" class="headerlink" title="1. 备注格式"></a>1. 备注格式</h2><p>[类型描述]，类型如下图所示</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">feat</td>
<td align="left">feature,即新开发的功能</td>
</tr>
<tr>
<td align="left">fix</td>
<td align="left">问题修复</td>
</tr>
<tr>
<td align="left">refactor</td>
<td align="left">重构代码</td>
</tr>
<tr>
<td align="left">doc</td>
<td align="left">增加文档(如ReadMe)、注释</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fix:修复身份证含字母X的用户无法注册问题 </span><br><span class="line">fix: 紧急修复生产线用户积分不显示的问题 </span><br><span class="line">feat:商品详情页功能 </span><br><span class="line">doc:增加项目readme文档，修改结算条款结算逻辑的注释</span><br></pre></td></tr></table></figure>


<h2 id="2-提交频率"><a href="#2-提交频率" class="headerlink" title="2. 提交频率"></a>2. 提交频率</h2><ol>
<li>每天下班前必须提交feature分支，并push到远程</li>
<li>hotfix、feature、bugfix、refactor分支尽量按照功能点或修复重构的问题及时commit（不要求push）<br><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/git%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data</title>
    <url>/2019/10/24/Spring%20Data%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<blockquote>
<p><strong>To Do</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different" target="_blank" rel="noopener">JDBC与JPA的区别</a><ul>
<li><code>JDBC是数据库访问的标准;JPA是ORM的标准</code></li>
<li><code>JPA和JDBC之间的主要区别是抽象层次:JDBC是与数据库交互的低级标准,JPA是同一目的的较高标准</code></li>
<li><code>JDBC是JPA的前身</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://www.jianshu.com/p/49b31ef74ff3" target="_blank" rel="noopener">Hibernate与Mybatis与Spring Data</a><ul>
<li><code>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装</code>【开发难度大】</li>
<li><code>MyBatis 本是apache的一个开源项目iBatis，着力于POJO与SQL之间的映射关系</code></li>
<li><code>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务</code>【SQL的自由度低】</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Predicate接口中的CriteriaQuery与CriteriaBuilder<ul>
<li><del><code>CriteriaQuery:表达式查询语句</code></del></li>
<li><code>CriteriaBuilder：面向对象查询语句(.equal(),.and(),.or(),.like())</code></li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://www.hollischuang.com/archives/1658" target="_blank" rel="noopener"><strong>JDBC事务和JTA事务</strong></a><ul>
<li><code>JDBC的一切行为包括事务是基于一个Connection的(在JDBC中是通过Connection对象进行事务管理(常用的和事务相关的方法是： setAutoCommit、commit、rollback等)</code></li>
<li><code>Java Transaction API是一个Java企业版 的应用程序接口，在Java环境中，允许完成跨越多个XA资源的分布式事务</code>【处理分布式事务】</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> <strong>关于关联对象的懒加载处理</strong></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>Question：</strong></p>
<ul>
<li>test中的数据库操作，会报tansactionrequired异常，事务会自动回滚roll back<ul>
<li><code>在test方法上手动设置@Transactional可以声明事务</code></li>
<li><code>在test方法上手动设置@Rollback(false)，可以禁止回滚</code></li>
</ul>
</li>
<li>进行save(Object)操作时，如果对象中有主键信息，会自动切换为修改操作<code>(因此：增、改均可以使用同一个方法save)</code><br><code>【小tips:可以在页面设置隐藏td用于存放id，可以根据实际情况进行自动判断，进行增加或者修改】</code></li>
</ul>
</blockquote>
<hr>
<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><blockquote>
<p>为了简化并统一持久层的各种实现技术的API，Spring Data提供了一套标准的API，整合不同持久层</p>
<ul>
<li><code>spring-data-commons：一套标准API</code></li>
<li><code>spring-data-jpa 基于整合JPA实现</code></li>
</ul>
</blockquote>
<hr>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.  简介"></a>1.  简介</h3><blockquote>
<p>SpringData支持的持久层技术：</p>
<ul>
<li>NoSQL 存储：<code>MongoDB （文档数据库）</code>、<code>Neo4j（图形数据库）</code>、<code>Redis（键/值存储）</code>、<code>Hbase（列族数据库）</code></li>
<li>关系数据存储技术：<code>JDBC</code>、<code>JPA</code><ul>
<li><code>JDBC：(Java Data Base Connectivity)，用于直接调用SQL命令,面向数据库</code></li>
<li><code>JPA：(Java Persistence API),操作实体对象,免除编写繁琐的SQL,面向对象</code><br>【<code>HIbernate即JPA的一种实现</code>】<br><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/Hibenate.png" alt=""></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2. 操作步骤"></a>2. 操作步骤</h3><blockquote>
<ol>
<li>配置 Spring 整合 JPA</li>
<li>在 Spring 配置文件中配置 Spring Data，让 Spring 为声明的接口创建代理对象。</li>
<li>声明持久层的接口，该接口继承自Repository接口(<code>开发中一般继承其子接口</code>)，并注入实体类及其主键类型<br>【<strong><code>spring容器实际通过AOP为我们提供的是SimpleJpaRepository（JpaRepository的实现类）的对象</code></strong>】</li>
<li>在接口中声明需要的Method</li>
<li>使用Spring为这些接口创建代理实例(<code>也可以通过JavaConfig,或者XML配置</code>)<br><code>&lt;jpa:repositories base-package=&quot;com.acme.repositories&quot;/&gt; (XML配置语句)</code></li>
<li>获取Repository实例注入并使用它</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.声明一个继承自Repository的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; </span><br><span class="line">	<span class="comment">// 声明要查询的方法</span></span><br><span class="line">	<span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过config为自定义接口创建代理对象</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注入Repository实例，并使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClient</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PersonRepository repository;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Person&gt; persons = repository.findByLastname(<span class="string">"Matthews"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Repository接口"><a href="#3-Repository接口" class="headerlink" title="3. Repository接口"></a>3. Repository接口</h3><p><code>Spring-data-commons中提供</code></p>
<blockquote>
<p>Repository接口是 Spring Data 的一个核心接口,但是并不提供任何method，为一个名义接口</p>
<ul>
<li><code>开发者在自定义子接口中定义method</code></li>
<li><code>Spring Data让我们可以只定义接口，只要遵循 Spring Data的规范，就</code><strong><code>无需写实现类</code></strong></li>
</ul>
</blockquote>
<h3 id="4-Repository子接口"><a href="#4-Repository子接口" class="headerlink" title="4. Repository子接口"></a>4. Repository子接口</h3><p><code>标准接口位于Spring-data-commons</code><br><code>扩展接口位于Spring-data-jpa</code></p>
<blockquote>
<ul>
<li>CrudRepository 标准接口 (<code>提供了最基本的对实体类的CRUD操作</code>)<ul>
<li><code>增删改：save、delete、deleteAll</code></li>
<li><code>查：findAll、findOne、count</code></li>
</ul>
</li>
<li>PagingAndSortingRepository 标准接口(<code>继承自CrudRepository，提供了分页与排序功能</code>)<ul>
<li><strong><code>排序</code></strong>：<code>Iterable&lt;T&gt; findAll(Sort sort);</code></li>
<li><strong><code>分页查询（含排序功能）</code></strong>：<code>Page&lt;T&gt; findAll(Pageable pageable);</code></li>
</ul>
</li>
<li>JpaRepository 扩展接口(<code>该接口提供了JPA的相关功能</code>)</li>
</ul>
</blockquote>
<p>|method|Description|<br>|:-|:-|:-|<br>|<code>List&lt;T&gt; findAll()</code> |查找所有实体|<br>|<code>List&lt;T&gt; findAll(Sort sort)</code> |排序、查找所有实体|<br>|<code>List&lt;T&gt; save(Iterable&lt;? extends T&gt; entities)</code>|保存集合|</p>
<blockquote>
<ul>
<li>JpaSpecificationExecutor 扩展接口(<code>不属于Repository体系，实现一组JPA Criteria查询相关的方法</code>)</li>
<li>Specification：Spring Data JPA提供的查询规范，用于复杂的查询(<code>类似于QBC查询</code>)</li>
<li>自定义Repository子接口</li>
</ul>
</blockquote>
<h2 id="二-操作流程"><a href="#二-操作流程" class="headerlink" title="二.操作流程"></a>二.操作流程</h2><p><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/Spring%20Data%20repository.png" alt=""></p>
<blockquote>
<p>在Spring Data repository 抽象的接口中心是仓库(Repository).</p>
</blockquote>
<h3 id="1-定义repository接口"><a href="#1-定义repository接口" class="headerlink" title="1. 定义repository接口"></a>1. 定义repository接口</h3><blockquote>
<p>自定义一个接口，继承某个Repository的子接口(<code>需要泛型注入Entity类和一个主键类型</code>)</p>
<ul>
<li>子接口举隅<ul>
<li><code>如果对象要实现CRUD操作，需要继承CrudRepository接口</code></li>
<li><code>如果还要在此基础上实现分页查询，需要继承PagingAndSortingRepository接口</code></li>
</ul>
</li>
<li>repository调整<ul>
<li><code>除了继承Spring Data接口，也能通过@RepositoryDefinition声明自定义的Repository接口</code></li>
<li><code>在自定义接口中，可以选择性地暴露某些method，从而实现定义自己的抽象</code><br>【暴露的接口，会通过动态代理获取实现类(如SimpleJapRepository)的method】</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个基础接口，供所有的domain接口使用(暴露findOne，save方法)</span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span> <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>,<span class="title">ID</span>&gt;</span>&#123;</span><br><span class="line">     <span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>;</span><br><span class="line">     <span class="function">T <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承基础接口（暴露通过email查询对象的方法）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-定义查询method"><a href="#2-定义查询method" class="headerlink" title="2. 定义查询method"></a>2. 定义查询method</h3><blockquote>
<p>Repository代理提供两种方式获取特定查询<br><code>依据方法名直接导出查询</code> + <code>手动定义查询</code></p>
</blockquote>
<h4 id="2-1-查找策略"><a href="#2-1-查找策略" class="headerlink" title="2.1  查找策略"></a>2.1  查找策略</h4><p><code>可用于仓库基础结构来解决查询</code></p>
<blockquote>
<ul>
<li>实现方式：<ul>
<li><code>xml配置(query-lookup-strategy属性)</code></li>
<li><code>注解声明(Enable${store}Repositories中声明queryLookupStrategy属性)</code></li>
</ul>
</li>
<li>策略分类 <ul>
<li><code>CREATE：通过查询方法名构建一个特别的数据查询</code></li>
<li><code>USE_DECLARED_QUERY：尝试找到一个声明查询并在找不到的时候抛出一个异常</code></li>
<li><code>CREATE_IF_NOT_FOUND：综合上述两者的功能</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2-2-创建查询"><a href="#2-2-创建查询" class="headerlink" title="2.2 创建查询"></a>2.2 创建查询</h4><blockquote>
<p>内置的查询生成器会剔除方法名中的关键字（<code>诸如find/read/query/count/get...by</code>），并解析剩下的内容</p>
<ul>
<li><code>Distinct标志：</code></li>
<li><code>by：后面一般为查询条件，多个条件以and/or连接</code></li>
<li><code>属性表达式你也可以使用可支持的操作比如Between(区间查询),LessThan,GreaterThan,Like(模糊查询)</code></li>
<li><code>方法解析支持为某些属性设置一个IgnoreCase标志</code></li>
<li><code>通过增加一个OrderBy字段实现按照属性排序</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">user</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Enables the distinct flag for the query</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname,String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">    <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-属性表达式"><a href="#2-3-属性表达式" class="headerlink" title="2.3 属性表达式"></a>2.3 属性表达式</h4><p><code>用于自定义条件查询</code></p>
<blockquote>
<p>属性表达式只能引用实体类的直接属性<br><code>内置查询器，依据固定规律，解析method名中的attribute作为查询条件</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析：1. 创建属性遍历x.address.zipCode</span></span><br><span class="line"><span class="comment">//      2. 如果上述解析不成功：则会按照驼峰法则从右开始拆分：AddressZip + Code --&gt; Address + ZipCode</span></span><br><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br><span class="line"><span class="comment">// 利用下划线(_)可以解决上述2中的歧义 【前提：Java属性命名中严格规范，不要使用下划线】</span></span><br><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-特殊参数处理"><a href="#2-4-特殊参数处理" class="headerlink" title="2.4 特殊参数处理"></a>2.4 特殊参数处理</h4><blockquote>
<ul>
<li>Pageable：</li>
<li>Slice：</li>
<li>Sort：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Spring框架提供的Pageable实例，来动态地实现添加分页</span></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="comment">// Slice仅仅知道是否有下一个Slice可用（消耗更小）</span></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="comment">// 利用...Sort实例实现排序</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;k</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-限制查询"><a href="#2-5-限制查询" class="headerlink" title="2.5 限制查询"></a>2.5 限制查询</h4><blockquote>
<p>关键字：<code>first</code>、<code>top</code>  （用于限制结果数）</p>
<ul>
<li><code>默认值为1，可以交替使用</code></li>
<li><code>可以使用distinct</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-流查询"><a href="#2-6-流查询" class="headerlink" title="2.6 流查询"></a>2.6 流查询</h4><p><code>Stream</code></p>
<blockquote>
<p>查询方法能对以JAVA 8的Stream为返回的结果进行逐步处理<br><code>一个数据流可能包裹底层数据存储特定资源，因此在使用后必须关闭。 你也可以使用close()方法或者JAVA 7 try-with-resources区块手动关闭数据流</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-创建repository实例"><a href="#3-创建repository实例" class="headerlink" title="3. 创建repository实例"></a>3. 创建repository实例</h3><blockquote>
<p>使用namespace，创建repository接口的bean实例</p>
</blockquote>
<ul>
<li>XML配置<blockquote>
<p><code>每一个Spring Data模块都包含repositories元素，因此简单的基于base-package定义即可进行Spring扫描</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/data/jpa"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repositories"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JavaConfig<blockquote>
<p>在一个JavaConfig类中使用<code>@Enable${store}Repositories</code>声明来触发repository的构建  </p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JPA声明</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(<span class="string">"com.acme.repositories"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> EntityManagerFactory <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// …</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>独立使用<blockquote>
<p>可以在spring容器外使用repository组件</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RepositoryFactorySupport factory = … <span class="comment">// Instantiate factory here</span></span><br><span class="line">UserRepository repository = factory.getRepository(UserRepository.class);</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义实现repositories"><a href="#4-自定义实现repositories" class="headerlink" title="4. 自定义实现repositories"></a>4. 自定义实现repositories</h3><blockquote>
<p>允许实现自定义的功能（<code>包括CRUD和查询功能</code>）</p>
</blockquote>
<h4 id="4-1-针对单一repositories"><a href="#4-1-针对单一repositories" class="headerlink" title="4.1 针对单一repositories"></a>4.1 针对单一repositories</h4><blockquote>
<p>自定义接口，并实现接口的方法，使用自定义的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// Your custom implementation</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-针对所有repositories"><a href="#4-2-针对所有repositories" class="headerlink" title="4.2 针对所有repositories"></a>4.2 针对所有repositories</h4><blockquote>
<p>添加自定义行为到所有的repository中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyRepositoryImpl</span><span class="params">(JpaEntityInformation entityInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">	                        EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line">	  <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></span><br><span class="line">	  <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// implementation goes here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-常用API-★★★"><a href="#三-常用API-★★★" class="headerlink" title="三. 常用API(★★★)"></a>三. 常用API(★★★)</h2><blockquote>
<p>本章节主要概述自定义数据库操作语句（<code>即Spring框架中repository实现类中未定义的sql</code>）</p>
</blockquote>
<h3 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1. 条件查询"></a>1. 条件查询</h3><h4 id="1-1-根据method名自动生成"><a href="#1-1-根据method名自动生成" class="headerlink" title="1.1 根据method名自动生成"></a>1.1 根据method名自动生成</h4><p><code>即利用属性表达式(Property expressions)</code></p>
<blockquote>
<p>在接口中定义方法(<code>利用关键字</code> + <code>按照固定格式</code>)，无需实现，内置查询器会自动生成并在调用方法时注入相应的查询语句</p>
<ul>
<li><code>精确查询一列：findBy列名</code></li>
<li><code>模糊查询一列：findBy列名Like</code></li>
<li><code>精确查询多列：findBy列名And列名Like</code> 【按照驼峰命名】</li>
</ul>
</blockquote>
<h4 id="1-2-配置-Query-★"><a href="#1-2-配置-Query-★" class="headerlink" title="1.2 配置@Query (★)"></a>1.2 配置@Query (★)</h4><blockquote>
<p>当方法名不按命名规则写的查询方法，可以配置@Query 绑定JPAL语句或者SQL语句</p>
<ul>
<li><code>使用</code><strong><code>JPAL</code></strong><code>语句，设置属性nativeQuery=false</code><br>【<code>实际上，JPAL语句，在语法上完全同HQL，只是称谓不同</code>】</li>
<li><code>使用</code><strong><code>SQL</code></strong><code>语句，设置属性nativeQuery=true</code></li>
</ul>
</blockquote>
<h4 id="1-3-实体类上配置-NamedQuery"><a href="#1-3-实体类上配置-NamedQuery" class="headerlink" title="1.3 实体类上配置@NamedQuery"></a>1.3 实体类上配置@NamedQuery</h4><blockquote>
<p>在接口的方法上配置<code>@Query</code>，并在实体类上定义<code>@NamedQuery(name=&quot;方法名&quot;，query=&quot;语句&quot;)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StandardRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Standard</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 1.1 根据方法名自动生成 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Standard&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.2 配置@Query</span></span><br><span class="line">	<span class="meta">@Query</span>(value=<span class="string">"from Standard where name = ?"</span> ,nativeQuery=<span class="keyword">false</span>)</span><br><span class="line">	<span class="comment">// nativeQuery 为 false 配置JPQL 、 为true 配置SQL </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Standard&gt; <span class="title">queryName</span><span class="params">(String name)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.3 配置@Query不写语句【然后在实体类中通过@NamedQuery定义】</span></span><br><span class="line">	<span class="meta">@Query</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Standard&gt; <span class="title">queryName2</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////// 1.3 实体类中的定义【声明在类上】</span></span><br><span class="line"><span class="meta">@NamedQueries</span>(&#123;</span><br><span class="line">	<span class="meta">@NamedQuery</span>(name=<span class="string">"Standard.queryName2"</span>,query=<span class="string">"from Standard where name=?"</span>)&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-带条件修改"><a href="#2-带条件修改" class="headerlink" title="2. 带条件修改"></a>2. 带条件修改</h3><blockquote>
<p>使用<code>@Query</code>注解完成 ， 搭配使用<code>@Modifying</code>标记修改、删除操作</p>
<ul>
<li><code>在测试test中进行增删改操作时，需要在test方法上设置事务，并手动定义不rollback</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义修改的方法</span></span><br><span class="line"><span class="meta">@Query</span>(value=<span class="string">"update Standard set minLength=?2 where id =?1"</span>)</span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMinLength</span><span class="params">(Integer id , Integer minLength)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在test中进行测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 声明事务</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>) <span class="comment">// 声明不回滚（默认在test中操作结束，自动回滚）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">	standRepository.updateMinLength(<span class="number">1</span>,<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-分页查询"><a href="#3-分页查询" class="headerlink" title="3. 分页查询"></a>3. 分页查询</h3><blockquote>
<ul>
<li>Spring Data提供的标准接口PagingAndSortingRepository中，定义了实现分页的方法<ul>
<li><code>Page&lt;T&gt; findAll(Pageable pageable)</code></li>
</ul>
</li>
<li><strong>参数</strong>：<code>SpringData提供了PageRequest对象，作为Pageable接口的实现类</code><br>【<code>注意：PageRequest的page页码从0开始</code>】<ul>
<li><code>public PageRequest(int page, int size)</code> 【构造器】</li>
<li><code>public PageRequest(int page, int size, Sort sort)</code></li>
</ul>
</li>
<li><strong>返回值</strong>：<code>分页的查询结果，会被自动封装为Page&lt;T&gt;</code><ul>
<li><code>总页数：TotalPages</code></li>
<li><code>页面详情：TotalElements</code></li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化Pageable对象(传入参数：当前页码，当前页总记录数)</span></span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(page - <span class="number">1</span>, rows);<span class="comment">//PageRequest的page页码从0开始，所以进行-1</span></span><br><span class="line"><span class="comment">// 调用findAll方法，返回结果自动封装为Page&lt;T&gt;类型</span></span><br><span class="line">Page&lt;Standard&gt; pageData = standardRepository.findAll(pageable);</span><br></pre></td></tr></table></figure>
<h3 id="4-查询关键字"><a href="#4-查询关键字" class="headerlink" title="4. 查询关键字"></a>4. 查询关键字</h3><blockquote>
<p>在method名称中可以使用的<br><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/SpringDataApi1.png" alt=""><br><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/SpringDataApi.png" alt=""><br><img src="https://raw.githubusercontent.com/yangsiyuan0/GitPic/master/evernote/SpringDataApi2.png" alt=""></p>
</blockquote>
<h2 id="四-参考文档"><a href="#四-参考文档" class="headerlink" title="四. 参考文档"></a>四. 参考文档</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h3><h4 id="1-1-命名空间-namespace"><a href="#1-1-命名空间-namespace" class="headerlink" title="1.1 命名空间(namespace)"></a>1.1 命名空间(namespace)</h4><blockquote>
<p>Spring Data的JPA模块包含一个允许定义存储库bean的自定义命名空间（<code>包含JPA特有的某些特征和元素属性</code>）</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:jpa</span>=<span class="string">"http://www.springframework.org/schema/data/jpa"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">"com.acme.repositories"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-注解配置"><a href="#1-2-注解配置" class="headerlink" title="1.2 注解配置"></a>1.2 注解配置</h4><blockquote>
<p>Spring Data JPA存储库支持不仅可以通过XML命名空间激活，还可以通过JavaConfig使用注释</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmbeddedDatabaseBuilder builder = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    <span class="keyword">return</span> builder.setType(EmbeddedDatabaseType.HSQL).build();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 重点：创建LocalContainerEntityManagerFactoryBean而不是EntityManagerFactory</span></span><br><span class="line"><span class="comment">// （因为前者包含了异常机制）</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HibernateJpaVendorAdapter vendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    vendorAdapter.setGenerateDdl(<span class="keyword">true</span>);</span><br><span class="line">    LocalContainerEntityManagerFactoryBean factory = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    factory.setJpaVendorAdapter(vendorAdapter);</span><br><span class="line">    factory.setPackagesToScan(<span class="string">"com.acme.domain"</span>);</span><br><span class="line">    factory.setDataSource(dataSource());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JpaTransactionManager txManager = <span class="keyword">new</span> JpaTransactionManager();</span><br><span class="line">    txManager.setEntityManagerFactory(entityManagerFactory());</span><br><span class="line">    <span class="keyword">return</span> txManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-持久化实体"><a href="#2-持久化实体" class="headerlink" title="2. 持久化实体"></a>2. 持久化实体</h3><h3 id="3-查询方法"><a href="#3-查询方法" class="headerlink" title="3. 查询方法"></a>3. 查询方法</h3><h3 id="4-存储过程"><a href="#4-存储过程" class="headerlink" title="4. 存储过程"></a>4. 存储过程</h3><h3 id="5-事务管理"><a href="#5-事务管理" class="headerlink" title="5. 事务管理"></a>5. 事务管理</h3><h3 id="6-审查"><a href="#6-审查" class="headerlink" title="6. 审查"></a>6. 审查</h3>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>SpringData</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>服务注册与发现</title>
    <url>/2019/10/23/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="1-Spring版本说明"><a href="#1-Spring版本说明" class="headerlink" title="1. Spring版本说明"></a>1. Spring版本说明</h3><p>本文档对工业界常用的服务治理框架、及其对应的技术栈进行预研。相关技术栈均基于JDK + Spring生态，因此在探索具体的服务治理框架之前，我们需要先对jdk、spring、springBoot、springCloud的相关版本进行相关梳理及选定：</p>
<table>
<thead>
<tr>
<th align="left">Spring Framework</th>
<th align="left">springBoot</th>
<th align="left">springCloud</th>
<th align="left">JDK</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Spring Framework 4.3.7.RELEASE</td>
<td align="left">1.5.2.RELEASE</td>
<td align="left">Dalston.RC1</td>
<td align="left">JDK6-8</td>
</tr>
<tr>
<td align="left">Spring Framework 4.3.13.RELEASE</td>
<td align="left">1.5.9.RELEASE</td>
<td align="left">Edgware.RELEASE</td>
<td align="left">JDK6-8</td>
</tr>
<tr>
<td align="left">Spring Framework 5.0.6.RELEASE</td>
<td align="left">2.0.2.RELEASE</td>
<td align="left">Finchley.BUILD-SNAPSHOT</td>
<td align="left">JDK8-10</td>
</tr>
<tr>
<td align="left"><strong>Spring Framework 5.0.7.RELEASE</strong></td>
<td align="left"><strong>2.0.3.RELEASE</strong></td>
<td align="left"><strong>Finchley.RELEASE</strong></td>
<td align="left"><strong>JDK8-10</strong></td>
</tr>
<tr>
<td align="left">Spring Framework 5.1.2.RELEASE</td>
<td align="left">2.1.x.RELEASE**</td>
<td align="left">Greenwich</td>
<td align="left">JDK8-12</td>
</tr>
<tr>
<td align="left">Spring Framework 5.*</td>
<td align="left">2.2.x.RELEASE</td>
<td align="left">Hoxton</td>
<td align="left">JDK8-12</td>
</tr>
</tbody></table>
<p>根据spring官方说明，<code>Spring Framework 5.1.*为目前的推荐版本</code>，对该版本的官方支持将持续到2019年底，而后将由5.2.<em>版本取代，而就springCloud的生态演进而言，Finchley版本相较于Dalston，有了极大的丰富与优化。<br>因此，本文档相关技术栈均基于*</em>SpringCloud Finchley**版本</p>
<blockquote>
<p><strong>关于SpringBoot的版本时间线如下：</strong></p>
<ul>
<li>2014年04月01号，Spring Boot 发布 v1.0.0.RELEASE，Spring Boot 正式商用</li>
<li>2014年06月11号，Spring Boot 发布 v1.1.0.RELEASE，主要修复了若干 Bug</li>
<li>2014年12月11号，Spring Boot 发布 v1.2.0.RELEASE，此版本更新的特性比较多，主要集成了 Servlet 3.1，支持 JTA、J2EE 等。</li>
<li>2015年11月16号，Spring Boot 发布 v1.3.0.RELEASE，增加了新 spring-boot-devtools 模块，缓存自动配置、颜色 banners 等新特性。</li>
<li>2016年07月29号，Spring Boot 发布 v1.4.0.RELEASE，以 Spring 4.3 为基础进行的构建，更新了很多第三方库的支持，重点增加了 Neo4J, Couchbase、 Redis 等 Nosql 的支持。</li>
<li>2017年01月30号，Spring Boot 发布 v1.5.0.RELEASE，更新了动态日志修改，增加 Apache Kafka、LDAP、事物管理等特性的支持。</li>
<li>2018年03月01号，Spring Boot 发布 v2.0.0.RELEASE</li>
<li>2018年10月30号，Spring Boot 发布 v2.1.0.RELEASE</li>
</ul>
</blockquote>
<h3 id="2-CAP原则"><a href="#2-CAP原则" class="headerlink" title="2. CAP原则"></a>2. CAP原则</h3><p>CAP原则又称CAP定理(1998年由加州大学的计算机科学家 Eric Brewer 提出)，指的是在一个分布式系统中有三个指标：一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</p>
<p>CAP 原则指的是，<code>这三个指标最多只能同时实现两点，不可能三者兼顾</code></p>
<ul>
<li><strong>一致性（C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li><strong>可用性（A）</strong>：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li><strong>分区容忍性（P）</strong>：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择【分区由网络故障、机器故障导致，具有外部不可抗力性，无法控制，是必选项】。</li>
</ul>
<p><strong>即：设计分布式数据系统，就是在一致性和可用性之间取一个平衡</strong></p>
<table>
<thead>
<tr>
<th align="left">组件名</th>
<th align="left">CAP</th>
<th align="left">一致性算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Eureka</td>
<td align="left">AP</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">Consul</td>
<td align="left">CP</td>
<td align="left">Raft</td>
</tr>
<tr>
<td align="left">Zookeeper</td>
<td align="left">CP</td>
<td align="left">Paxos</td>
</tr>
<tr>
<td align="left">etcd</td>
<td align="left">CP</td>
<td align="left">Raft</td>
</tr>
<tr>
<td align="left">nacos</td>
<td align="left">AP</td>
<td align="left">Raft</td>
</tr>
</tbody></table>
<h2 id="二-常用服务治理框架"><a href="#二-常用服务治理框架" class="headerlink" title="二.常用服务治理框架"></a>二.常用服务治理框架</h2><h3 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1. Eureka(*)"></a>1. Eureka(*)</h3><p>Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。其也是<strong>目前使用最广泛的服务发现框架</strong>。<br>Eureka包含两个组件：Eureka Server(<code>即服务端，注册中心</code>)和Eureka Client(<code>即客户端，服务提供者/消费者</code>)</p>
<ol>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址给消费者。</li>
<li>服务消费者从提供者地址中调用消费者<br><img src="en-resource://database/5773:1" alt="d810ebfac7c63d66515eec9ae47d5eae.png"></li>
</ol>
<h3 id="2-Consul"><a href="#2-Consul" class="headerlink" title="2. Consul"></a>2. Consul</h3><p>Spring Cloud Consul项目是针对Consul的服务治理实现。Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。</p>
<ul>
<li>使用Go语言编写，支持win、linux、mac全平台</li>
<li>Consul和Eureka不同，Eureka只需要在项目中加入服务端依赖，就可以作为服务端使用；Consul需要从官网下载，并单独安装</li>
<li>Consul服务器使用 Raft 协议(<code>要求必须过半数的节点都写入成功才认为注册成功 Leader 挂掉时，重新选举期间整个 Consul 不可用</code>)复制状态，保证了强一致性。相较于Eurake，高可用及效率均有损失。</li>
</ul>
<p><img src="en-resource://database/5767:1" alt="d6a016b0ac5ee80914c24f1799beaafd.png"></p>
<h3 id="3-Dubbo-Zookeeper"><a href="#3-Dubbo-Zookeeper" class="headerlink" title="3. Dubbo+Zookeeper"></a>3. Dubbo+Zookeeper</h3><p>Dubbo是一个由阿里巴巴开源的分布式服务框架，提供面向接口的远程方法调用(RPC)，智能容错和负载均衡，以及服务自动注册和发现等功能，其直接使用socket通信。传输效率高。Dubbo主要作用是提供服务治理<br>ZooKeeper是一个开源的分布式协调服务，为分布式应用提供配置维护、域名服务、分布式同步、组服务等功能。ZooKeeper是Dubbo的推荐注册中心，提供服务注册功能（<code>Dubbo也还可以搭配其他注册中心：Multicast注册中、Redis注册中心、Simple注册中心</code>）</p>
<p><em>PS：最新Spring社区孵化的Spring Cloud Alibaba，默认选用了Nacos作为注册中心，可以更加便捷地使用Ribbon或Feign来实现服务消费</em></p>
<h3 id="4-Nacos"><a href="#4-Nacos" class="headerlink" title="4. Nacos"></a>4. Nacos</h3><p>Nacos是由阿里巴巴开源的动态服务发现、配置管理和服务管理平台。Nacos提供了如下关键特性：服务发现和服务健康监测、动态配置服务、动态 DNS 服务、服务及其元数据管理。<br>和Consul一样，Nacos也需要从官网下载服务，进行单独启动<br><code>下图为Nacos官网提供的架构图：</code><br><img src="en-resource://database/5769:1" alt="352af1f2eb7fbf5f65e869893ac99633.png"></p>
<h3 id="5-etcd"><a href="#5-etcd" class="headerlink" title="5. etcd"></a>5. etcd</h3><p>etcd是一个采用http协议的分布式键值对存储系统，因其易用，简单。很多系统都采用或支持etcd作为服务发现的一部分，比如kubernetes。但其只是一个存储系统，如果想要提供完整的服务发现功能，必须搭配一些第三方的工具，搭建操作相对麻烦。</p>
<h3 id="6-SpringCloud-Alibaba"><a href="#6-SpringCloud-Alibaba" class="headerlink" title="6. SpringCloud Alibaba"></a>6. SpringCloud Alibaba</h3><p>SpringCloud Alibaba作为一款<code>旨在打造更符合中国国情的微服务体系</code>的开源组件，目前主要提供了服务发现、配置管理、高可用防护、基于RocketMQ的消息中间件等功能。其既提供了基于Nacos+Ribbon/Feign的服务治理方案，又支持基于Nacos+Dubbo的rpc服务治理方案。<br><code>下图nacas启动后的管理界面:</code></p>
<h2 id="三-Eureka项目实践"><a href="#三-Eureka项目实践" class="headerlink" title="三. Eureka项目实践"></a>三. Eureka项目实践</h2><h3 id="1-Eureka注册中心搭建-单机"><a href="#1-Eureka注册中心搭建-单机" class="headerlink" title="1. Eureka注册中心搭建(单机)"></a>1. Eureka注册中心搭建(单机)</h3><h4 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1). pom依赖"></a>1). pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka依赖【Springboot1.x中 artifactId 为 spring-cloud-starter-netflix-eureka-server，注意区分】--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-启动类注解"><a href="#2-启动类注解" class="headerlink" title="2). 启动类注解"></a>2). 启动类注解</h4><p>通过在启动类上添加注解<code>@EnableEurekaServer</code>，为该应用开启注册中心功能</p>
<h4 id="3-application-properties配置"><a href="#3-application-properties配置" class="headerlink" title="3). application.properties配置"></a>3). application.properties配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">spring.application.name=NewsEditingSuitCenter</span></span><br><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="string">server.port=1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主机名</span></span><br><span class="line"><span class="string">eureka.instance.hostname=eureka1</span></span><br><span class="line"><span class="comment">#服务名，默认取spring.application.name 配置值，没有则显示unknown</span></span><br><span class="line"><span class="comment">#eureka.instance.appname=NewsEditingSuitCenter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册时显示ip【即在eureka管理页面显示的格式为ip地址】</span></span><br><span class="line"><span class="string">eureka.instance.prefer-ip-address=false</span></span><br><span class="line"><span class="comment">#注册时显示ip的配置方案【spring.cloud.client.ip-address即为本机ip】</span></span><br><span class="line"><span class="comment">#eureka.instance.prefer-ip-address=true</span></span><br><span class="line"><span class="comment">#eureka.instance.hostname=$&#123;spring.cloud.client.ip-address&#125;</span></span><br><span class="line"><span class="comment">#eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表示是否将自己注册在EurekaServer上，默认为true。由于当前应用就是EurekaServer，所以置为false</span></span><br><span class="line"><span class="string">eureka.client.register-with-eureka=false</span></span><br><span class="line"><span class="comment">#表示表示是否从EurekaServer获取注册信息，默认为true。单节点不需要同步其他的EurekaServer节点的数据</span></span><br><span class="line"><span class="string">eureka.client.fetch-registry=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka server地址</span></span><br><span class="line"><span class="string">eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭自我保护(生产时打开该选项)</span></span><br><span class="line"><span class="comment">#如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制</span></span><br><span class="line"><span class="comment">#1. 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务、</span></span><br><span class="line"><span class="comment">#2. 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点、</span></span><br><span class="line"><span class="comment">#3. 当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中</span></span><br><span class="line"><span class="string">eureka.server.enable-self-preservation=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扫描失效服务的间隔时间（缺省为60*1000ms）</span></span><br><span class="line"><span class="string">eureka.server.eviction-interval-timer-in-ms=5000</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Eureka注册中心实现高可用"><a href="#2-Eureka注册中心实现高可用" class="headerlink" title="2. Eureka注册中心实现高可用"></a>2. Eureka注册中心实现高可用</h3><p>运行多个Eureka server实例，并进行互相注册即可实现注册中心的高可用<br>Eureka不允许在单台主机(即同一个ip)上搭建高可用服务，可以利用本机hosts文件构造本地域名来模拟多机，下述过程即是采用该方式进行搭建</p>
<h4 id="1-hosts文件配置"><a href="#1-hosts文件配置" class="headerlink" title="1). hosts文件配置"></a>1). hosts文件配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 eureka1</span><br><span class="line">127.0.0.1 eureka2</span><br><span class="line">127.0.0.1 eureka3</span><br></pre></td></tr></table></figure>

<h4 id="2-搭建多个Eureka-server"><a href="#2-搭建多个Eureka-server" class="headerlink" title="2). 搭建多个Eureka server"></a>2). 搭建多个Eureka server</h4><p>将上文”<code>1. Eureka注册中心搭建(单机)</code>“中搭建的项目，复制多个即可</p>
<h4 id="3-修改Eureka-server服务的application-properties配置"><a href="#3-修改Eureka-server服务的application-properties配置" class="headerlink" title="3). 修改Eureka server服务的application.properties配置"></a>3). 修改Eureka server服务的application.properties配置</h4><ul>
<li>节点1配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">spring.application.name=NewsEditingSuitCenter</span></span><br><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="string">server.port=1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主机名</span></span><br><span class="line"><span class="string">eureka.instance.hostname=eureka1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否将自己注册在EurekaServer上</span></span><br><span class="line"><span class="string">eureka.client.register-with-eureka=true</span></span><br><span class="line"><span class="comment">#是否从EurekaServer获取注册信息，多节点需要同步其他的EurekaServer节点的数据</span></span><br><span class="line"><span class="string">eureka.client.fetch-registry=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka server地址【指向其他节点地址】</span></span><br><span class="line"><span class="string">eureka.client.serviceUrl.defaultZone=http://eureka2:1112/eureka/,http://eureka3:1113/eureka/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>节点2配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">spring.application.name=NewsEditingSuitCenter</span></span><br><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="string">server.port=1112</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主机名</span></span><br><span class="line"><span class="string">eureka.instance.hostname=eureka2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否将自己注册在EurekaServer上</span></span><br><span class="line"><span class="string">eureka.client.register-with-eureka=true</span></span><br><span class="line"><span class="comment">#是否从EurekaServer获取注册信息，多节点需要同步其他的EurekaServer节点的数据</span></span><br><span class="line"><span class="string">eureka.client.fetch-registry=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka server地址【指向其他节点地址】</span></span><br><span class="line"><span class="string">eureka.client.serviceUrl.defaultZone=http://eureka2:1112/eureka/,http://eureka3:1113/eureka/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>节点3配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">spring.application.name=NewsEditingSuitCenter</span></span><br><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="string">server.port=1113</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#主机名</span></span><br><span class="line"><span class="string">eureka.instance.hostname=eureka3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否将自己注册在EurekaServer上</span></span><br><span class="line"><span class="string">eureka.client.register-with-eureka=true</span></span><br><span class="line"><span class="comment">#是否从EurekaServer获取注册信息，多节点需要同步其他的EurekaServer节点的数据</span></span><br><span class="line"><span class="string">eureka.client.fetch-registry=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#eureka server地址【指向其他节点地址】</span></span><br><span class="line"><span class="string">eureka.client.serviceUrl.defaultZone=http://eureka1:1111/eureka/,http://eureka2:1112/eureka/</span></span><br></pre></td></tr></table></figure>


<h3 id="3-注册服务至Eureka【构建生产者】"><a href="#3-注册服务至Eureka【构建生产者】" class="headerlink" title="3. 注册服务至Eureka【构建生产者】"></a>3. 注册服务至Eureka【构建生产者】</h3><p>此步骤，即将现有的快融服务注册到Eureka注册中心</p>
<h4 id="1-pom依赖-1"><a href="#1-pom依赖-1" class="headerlink" title="1). pom依赖"></a>1). pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka client 适配springboot1.*--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;dependency&gt;            </span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            </span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;       </span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- eureka client 适配springboot2*--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-<span class="tag">&lt;<span class="name">u</span>&gt;</span>netflix<span class="tag">&lt;/<span class="name">u</span>&gt;</span>-<span class="tag">&lt;<span class="name">u</span>&gt;</span>eureka<span class="tag">&lt;/<span class="name">u</span>&gt;</span>-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-启动类注解-1"><a href="#2-启动类注解-1" class="headerlink" title="2). 启动类注解"></a>2). 启动类注解</h4><p>通过在启动类上添加注解`@EnableDiscoveryClient，激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.dayang.portal.db.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-application-properties配置-1"><a href="#3-application-properties配置-1" class="headerlink" title="3). application.properties配置"></a>3). application.properties配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">spring.application.name=dyportalserver</span></span><br><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="string">server.port=9001</span></span><br><span class="line"><span class="comment">#eureka server地址</span></span><br><span class="line"><span class="string">eureka.client.serviceUrl.defaultZone=http://eureka1:1111/eureka/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进阶配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#状态页面的URL，相对路径,默认值是/info【https需要使用绝对路径配置eureka.instance.status-page-url】</span></span><br><span class="line"><span class="string">eureka.instance.status-page-url-path=$&#123;server.servlet.context-path&#125;/actuator/info</span></span><br><span class="line"><span class="comment">#健康检查页面的URL，相对路径,默认值是/health【https需要使用绝对路径配置eureka.instance.health-check-url】</span></span><br><span class="line"><span class="string">eureka.instance.health-check-url-path=$&#123;server.servlet.context-path&#125;/acturtor/health</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#该实例的主页url,相对路径【绝对路径：eureka.instance.home-page-url】</span></span><br><span class="line"><span class="comment">#eureka.instance.home-page-url-path=$&#123;server.servlet.context-path&#125;</span></span><br><span class="line"><span class="comment">#是否注册为服务</span></span><br><span class="line"><span class="string">eureka.client.register-with-eureka=true</span></span><br><span class="line"><span class="comment">#是否检索服务</span></span><br><span class="line"><span class="string">eureka.client.fetch-registry=true</span></span><br><span class="line"><span class="comment">############# 续约配置  ##############</span></span><br><span class="line"><span class="comment"># 心跳时间，即服务续约间隔时间（缺省为30s）</span></span><br><span class="line"><span class="string">eureka.instance.lease-renewal-interval-in-seconds=5</span></span><br><span class="line"><span class="comment"># 发呆时间，即服务续约到期时间（缺省为90s）</span></span><br><span class="line"><span class="string">eureka.instance.lease-expiration-duration-in-seconds=10</span></span><br><span class="line"><span class="comment"># 开启健康检查（依赖spring-boot-starter-actuator）</span></span><br><span class="line"><span class="string">eureka.client.healthcheck.enabled=true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-基于Ribbon实现服务间调用【构建消费者】"><a href="#4-基于Ribbon实现服务间调用【构建消费者】" class="headerlink" title="4. 基于Ribbon实现服务间调用【构建消费者】"></a>4. 基于Ribbon实现服务间调用【构建消费者】</h3><p>Spring Cloud Ribbon是基于基于HTTP和TCP的客户端负载均衡的工具(<code>基于Netflix Ribbon实现</code>)，它被集成在springCloud的基础设施中，并不需要独立部署(简而言之，引入依赖开启配置即可使用)</p>
<p><strong>客户端负载均衡：</strong><br><code>区别于基于F5(硬件)、nginx(软件)等实现的服务端负载均衡，是将服务清单维护在服务端，按照算法进行请求分发；
客户端负载均衡，是由客户端(即服务消费者)自行维护服务节点清单【从Eureka server获取】，由客户端自行选择请求节点</code></p>
<pre><code>Ribbon实现客户端负载均衡的方式，是通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。(相应的，当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现)</code></pre><h4 id="1-pom依赖-2"><a href="#1-pom依赖-2" class="headerlink" title="1). pom依赖"></a>1). pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-声明RestTemplate"><a href="#2-声明RestTemplate" class="headerlink" title="2). 声明RestTemplate"></a>2). 声明RestTemplate</h4><p>通过显示地声明一个RestTemplate对象，并添加注解<code>@LoadBalanced</code>，开启客户端负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplicationpublic</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: ysy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Spring Boot &gt;= 1.4版本，RestTemplate不再自动声明</span></span><br><span class="line"><span class="comment">     * 【<span class="doctag">@LoadBalanced</span>用于开启LoadBalancerInterceptor，实现通过服务名实现调用】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder </span></span></span><br><span class="line"><span class="function"><span class="params">builder)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Do any additional configuration here</span></span><br><span class="line">       <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-利用RestTemplate发起请求"><a href="#3-利用RestTemplate发起请求" class="headerlink" title="3). 利用RestTemplate发起请求"></a>3). 利用RestTemplate发起请求</h4><p>RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法。相较于我们目前使用的HTTPClient，大大提高客户端的编写效率。</p>
<p><code>关于httpClient、OkHttpClient、RestTemplate三者的比较，可以参见</code><a href="https://stackoverflow.com/questions/53795268/should-i-use-httpurlconnection-or-resttemplate" target="_blank" rel="noopener">HttpUrlConnection VS RestTemplate</a></p>
<blockquote>
<p><strong>RestTemplate常用API：</strong></p>
<ul>
<li>getForEntity(String url, Class<T> responseType, Object… uriVariables)</li>
<li>getForEntity(URI url, Class<T> responseType)</li>
<li>getForObject(String url, Class<T> responseType, Object… uriVariables)</li>
<li>getForObject(URI url, Class<T> responseType)</li>
<li>postForObject(URI url, @Nullable Object request, Class<T> responseType)</li>
<li>postForObject(String url, @Nullable Object request, Class<T> responseType, Object… uriVariables)</li>
<li>postForObject(String url, @Nullable Object request, Class<T> responseType,Map&lt;String, ?&gt; uriVariables)</li>
</ul>
</blockquote>
<ul>
<li><strong>GET请求样例【手动获取实例地址】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取restTemplate对象</span></span><br><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">LoadBalancerClient loadBalancerClient;    </span><br><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务地址</span></span><br><span class="line">ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"eureka-client"</span>);        </span><br><span class="line">String url = <span class="string">"http://"</span> + serviceInstance.getHost() + <span class="string">":"</span> + serviceInstance.getPort();</span><br><span class="line"><span class="comment">//第一个参数表示服务地址：dyportalserver为在Eureka中注册的服务名</span></span><br><span class="line"><span class="comment">//第二个参数表示返回值类型</span></span><br><span class="line"><span class="comment">//后续为可变参数，分别替换请求路径中的占位符变量</span></span><br><span class="line">String name = restTemplate.getForObject(url + <span class="string">"/test?name=&#123;1&#125;"</span>, String.class, <span class="string">"智新测试"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST请求样例【自动获取实例地址】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数表示服务地址：dyportalserver为在Eureka中注册的服务名</span></span><br><span class="line"><span class="comment">//第二个参数表示返回值类型</span></span><br><span class="line">CloudType cloudType = S.getForObject(<span class="string">"http://dyportalserver/UserInfoController/getCloudType"</span>, CloudType.class);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST请求样例 【上面是理想转态，下面才是现实】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCloudType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回json封装的数据</span></span><br><span class="line">      String res = restTemplate.postForObject(<span class="string">"http://"</span> + serviceName + contextPath +Constants_portal.CLOUDTYPE_ADDRESS_SUFFIX, <span class="keyword">null</span>, String.class);</span><br><span class="line">  <span class="comment">// 利用TypeToken对带泛型的对象进行反序列化</span></span><br><span class="line">      Type typeToken = <span class="keyword">new</span> TypeToken&lt;XtcpCommonReponse&lt;CloudType&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">      XtcpCommonReponse&lt;CloudType&gt; response = <span class="keyword">new</span> Gson().fromJson(res, typeToken);</span><br><span class="line">      logger.debug(<span class="string">"CloudType: "</span> + response.getData());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>POST请求样例【带参数】</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>    </span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getParameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//构造请求头</span></span><br><span class="line">      HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">      headers.add(<span class="string">"userId"</span>, <span class="string">"admin"</span>);</span><br><span class="line">      headers.add(<span class="string">"tenantId"</span>, <span class="string">"dayang.com"</span>);</span><br><span class="line">      headers.add(<span class="string">"token"</span>, <span class="string">"token"</span>);</span><br><span class="line">      headers.setContentType(MediaType.MULTIPART_FORM_DATA);</span><br><span class="line">      <span class="comment">//构造请求体</span></span><br><span class="line">      MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">      map.add(<span class="string">"parameterCode"</span>,<span class="string">"PUB_CRECRE"</span>);</span><br><span class="line">      HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;&gt;(map, headers);</span><br><span class="line">      <span class="comment">//发起请求</span></span><br><span class="line">      String res = restTemplate.postForObject(<span class="string">"http://"</span> + serviceName + contextPath + Constants_portal.PARAMETER_QUERY_ADDRESS_SUFFIX, formEntity, String.class);</span><br><span class="line">      <span class="comment">// 处理返回值</span></span><br><span class="line">      Type typeToken = <span class="keyword">new</span> </span><br><span class="line">TypeToken&lt;XtcpCommonReponse&lt;List&lt;CcsParameter&gt;&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">      XtcpCommonReponse&lt;List&lt;CcsParameter&gt;&gt; response = <span class="keyword">new</span> Gson().fromJson(res, typeToken);</span><br><span class="line">      List&lt;CcsParameter&gt; parameterList = response.getData();</span><br></pre></td></tr></table></figure>

<h3 id="5-基于Feign实现服务间调用"><a href="#5-基于Feign实现服务间调用" class="headerlink" title="5. 基于Feign实现服务间调用(*)"></a>5. 基于Feign实现服务间调用(*)</h3><p>Spring Cloud Feign是一套基于Netflix Feign实现的<strong>声明式</strong>服务调用客户端，只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现</p>
<p>另外，Feign同时整合了Hystrix功能，支持服务容错保护</p>
<h4 id="1-pom依赖-3"><a href="#1-pom依赖-3" class="headerlink" title="1). pom依赖"></a>1). pom依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-启动类注解-2"><a href="#2-启动类注解-2" class="headerlink" title="2). 启动类注解"></a>2). 启动类注解</h4><p>通过在启动类上添加注解<code>@EnableFeignClients</code>，开启扫描Spring Cloud Feign客户端的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplicationpublic</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建Feign的客户端接口定义"><a href="#3-创建Feign的客户端接口定义" class="headerlink" title="3). 创建Feign的客户端接口定义"></a>3). 创建Feign的客户端接口定义</h4><p>Feign提供的是声明式的服务绑定功能，即使用<code>@FeignClient</code>注解即可实现对服务的绑定</p>
<ul>
<li><strong>构造Feign客户端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过注解将该接口与门户后端服务进行绑定【服务名不区分大小写】</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"dyportalserver"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DypotalClient</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用mvc注解绑定具体的REST接口【不带参数】</span></span><br><span class="line">     <span class="meta">@PostMapping</span>(<span class="string">"dyportalserver/UserInfoController/getCloudType"</span>) </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getCloudType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用mvc注解绑定具体的REST接口【带参数】</span></span><br><span class="line">     <span class="meta">@PostMapping</span>(<span class="string">"dyportalserver/ParameterController/getParameter"</span>) </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(@RequestHeader(<span class="string">"tenantId"</span>)</span> String tenantId, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"userId"</span>)</span> String userId, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"token"</span>)</span> String token, @<span class="title">RequestParam</span><span class="params">(<span class="string">"parameterCode"</span>)</span> String parameterCode)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>调用Feign客户端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入Feign客户端</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FeignClientUtil feignClientUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCloudTypeFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String res = feignClientUtil.getCloudType();</span><br><span class="line">   Type typeToken = <span class="keyword">new</span> TypeToken&lt;XtcpCommonReponse&lt;CloudType&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">   XtcpCommonReponse&lt;CloudType&gt; response = <span class="keyword">new</span> Gson().fromJson(res, typeToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getParameterFeign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String res = feignClientUtil.getParameter(<span class="string">"dayang.com"</span>, <span class="string">"admin"</span>, <span class="string">"token"</span>, <span class="string">"PUB_CRECAS"</span>);</span><br><span class="line">    Type typeToken = <span class="keyword">new</span> TypeToken&lt;XtcpCommonReponse&lt;List&lt;CcsParameter&gt;&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">    XtcpCommonReponse&lt;List&lt;CcsParameter&gt;&gt; response = <span class="keyword">new</span> Gson().fromJson(res, typeToken);</span><br><span class="line">    List&lt;CcsParameter&gt; parameterList = response.getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
        <tag>Feign</tag>
        <tag>Ribbon</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
